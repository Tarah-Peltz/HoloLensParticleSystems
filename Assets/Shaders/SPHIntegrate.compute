//This is based upon the work from this GitHub:https://github.com/multiprecision/sph_opengl.git
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
struct Particle
{
	float4 positionAndDensity;
	float4 velocityAndPressure;
	float4 force;
};



// Particle's data, shared with the shader
RWStructuredBuffer<Particle> particleBuffer;

// Variables passed from the CPU
float _timeStep;
int _numberOfParticles;
float _boundaryDamping;

[numthreads(8, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	float3 acceleration = particleBuffer[id.x].force.xyz / particleBuffer[id.x].positionAndDensity.w;
	float3 newVelocity = particleBuffer[id.x].velocityAndPressure.xyz + _timeStep * acceleration;
	float3 newPosition = particleBuffer[id.x].positionAndDensity.xyz + _timeStep * newVelocity;
	//HAS TO BE A BETTER WAY TO DO THIS
	if (newPosition.x <= -2) {
		newPosition.x = -2;
		newVelocity.x *= -1 * _boundaryDamping;
	}
	else if (newPosition.x >= 2)
	{
		newPosition.x = 2;
		newVelocity.x *= -1 * _boundaryDamping;
	}
	if (newPosition.y <= 0)
	{
		newPosition.y = 0;
		newVelocity.y *= -1 * _boundaryDamping;
	}
	else if (newPosition.y >= 6)
	{
		newPosition.y = 6;
		newVelocity.y *= -1 * _boundaryDamping;
	}
	if (newPosition.z <= -2) {
		newPosition.z = -2;
		newVelocity.z *= -1 * _boundaryDamping;
	}
	else if (newPosition.z >= 2) {
		newPosition.z = 2;
		newVelocity.z *= -1 * _boundaryDamping;
	}
	

	particleBuffer[id.x].velocityAndPressure.xyz = newVelocity;
	particleBuffer[id.x].positionAndDensity.xyz = newPosition;
}
