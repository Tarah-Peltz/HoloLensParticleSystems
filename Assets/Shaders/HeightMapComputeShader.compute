// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Particle
{
	float4 position;
	float4 velocity;
};

// Particle's data, shared with the shader
RWStructuredBuffer<Particle> particleBuffer;
Texture2D<float4> HeightMapTexture;
SamplerState samplerHeightMapTexture;
//StructuredBuffer<float4> heightMap;

// Variables passed from the CPU
float _time;
float4 textureCenter;
float textureXLength;
float textureZLength;


[numthreads(8, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	//https://msdn.microsoft.com/en-us/library/windows/desktop/bb509699(v=vs.85).aspx
	float4 texLookup = HeightMapTexture.SampleLevel(samplerHeightMapTexture, float2((particleBuffer[id.x].position.x + (textureXLength / 2) - textureCenter.x)/ textureXLength, 
		(particleBuffer[id.x].position.z + (textureZLength / 2) - textureCenter.z) / textureZLength), 0.0);
	particleBuffer[id.x].position.y = texLookup.y * 6 - 6;

	//particleBuffer[id.x].position.x = particleBuffer[id.x].position.x + sin(_time * 3.141592) / 100;
	//particleBuffer[id.x].position.z = particleBuffer[id.x].position.z + cos(_time * 3.141592) / 100;
	//particleBuffer[id.x].position.x = heightMap[id.x];
	//particleBuffer[id.x].position.z = heightMap[id.xy];

	//float xRatio = (particleBuffer[id.x].position.x + textureXLength - textureCenter.x) / textureXLength;
	//float zRatio = (particleBuffer[id.x].position.z + textureZLength - textureCenter.z) / textureZLength;
	//particleBuffer[id.x].position.y = particleBuffer[id.x].position.y + heightMapTexture.SampleLevel(samplerheightMapTexture, xRatio, zRatio, 0) + _time;
	//particleBuffer[id.x].position.y = _heightMapTexture.SampleLevel(sampler_heightMapTexture, float2(1,1), 0, int2(0,0)).r ;
}